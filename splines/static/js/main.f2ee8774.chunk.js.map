{"version":3,"sources":["spline.tsx","canvas.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Point","x","y","this","Splines","numKnots","order","knots","controls","points","lambda","learning_rate","xmat","Matrix","ymat","drawing","setKnotsAndOrder","assert","i","push","Array","fill","concat","length","numBasis","slice","setPoints","k","findInterval","deBoor","xarr","yarr","point","yhat","eval","transpose","left","mmul","add","identity","columns","mul","right","beta","solve","to1DArray","update","get","d","j","r","alpha","ctx","started","height","canvas","width","colors","clearRect","control","strokeStyle","beginPath","moveTo","lineTo","stroke","lineWidth","transformX","transformY","fillStyle","arc","Math","PI","window","requestAnimationFrame","callback","step_size","fitIter","draw","Canvas","props","splines","React","createRef","numberOfKnots","degreeOfSpline","componentDidUpdate","hue","drawClickMeText","font","textAlign","fillText","current","getContext","onclick","ev","offsetX","offsetY","drawLoop","ref","Component","App","useState","setNumberOfKnots","setDegreeOfSpline","className","id","href","Slider","onChange","e","target","value","defaultValue","min","max","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f2ee8774.chunk.js","sourcesContent":["import assert from \"assert\";\nimport { Matrix, solve } from \"ml-matrix\";\n\nclass Point {\n    x: number = 0;\n    y: number = 0;\n\n    constructor(x: number, y: number) {\n        this.x = x\n        this.y = y\n    }\n}\n\n\nclass Splines {\n    knots: number[] = [0, 1]\n    order: number = 3\n    controls: number[] = []\n    points: Point[] = []\n    lambda: number = 0.0001\n    learning_rate: number = 0.05\n    xmat: Matrix = new Matrix(0, 0)\n    ymat: Matrix = new Matrix(0, 0)\n    drawing = false\n\n    constructor(numKnots: number, order: number) {\n        this.setKnotsAndOrder(numKnots, order)\n    }\n\n    setKnotsAndOrder(numKnots: number, order: number) {\n        assert(numKnots > 1)\n        this.drawing = false\n        let knots = []\n        for (let i = 0; i < numKnots; i++) {\n            knots.push(i / (numKnots - 1))\n        }\n        knots = new Array(order).fill(0).concat(knots, new Array(order).fill(1))\n        this.knots = knots\n        this.order = order\n        // Resize controls array to right size\n        while (this.controls.length < this.numBasis()) {\n            this.controls.push(0)\n        }\n        this.controls = this.controls.slice(0, this.numBasis())\n        this.setPoints(this.points)\n        // this.drawLoop()\n    }\n\n    findInterval(x: number): number {\n        for (let i = 0; i < this.knots.length; i++) {\n            if (x < this.knots[i]) {\n                return i - 1;\n            }\n        }\n        assert(false);\n    }\n\n    eval(x: number, controls: number[]) {\n        let k = this.findInterval(x);\n        return this.deBoor(k, x, controls)\n    }\n\n    setPoints(points: Point[]) {\n        this.points = points\n        let xarr: number[][] = [];\n        let yarr: number[] = [];\n        for (let point of this.points) {\n            // Compute new basis at the points\n            let controls = new Array(this.numBasis()).fill(0);\n            xarr.push([])\n            yarr.push(point.y);\n            for (let i = 0; i < controls.length; i++) {\n                controls[i] = 1;\n                let yhat = this.eval(point.x, controls);\n                xarr[xarr.length - 1].push(yhat);\n                controls[i] = 0;\n            }\n        }\n        this.xmat = new Matrix(xarr);\n        this.ymat = new Matrix([yarr]).transpose();\n    }\n\n    fitExact() {\n        // Ridge regression estimator\n        const left = this.xmat.transpose().mmul(this.xmat).add(Matrix.identity(this.xmat.columns).mul(this.lambda))\n        const right = this.xmat.transpose().mmul(this.ymat)\n        const beta = solve(left, right).to1DArray()\n        this.controls = beta;\n    }\n\n    fitIter() {\n        if (this.points.length === 0) {\n            return 0;\n        }\n        const xmat = this.xmat\n        const ymat = this.ymat\n        let beta = new Matrix([this.controls]).transpose()\n        const grad = xmat.transpose().mmul(ymat).mul(-2).add(xmat.transpose().mmul(xmat).mmul(beta).mul(2))\n        const update = grad.mul(this.learning_rate * -1)\n        this.controls = beta.add(update).to1DArray()\n        const step_size = update.transpose().mmul(update).get(0, 0)\n        return step_size\n    }\n\n    deBoor(k: number, x: number, controls: number[]) {\n        // Evaluates S(x).\n\n        // Arguments\n        // ---------\n        // k: Index of knot interval that contains x.\n        // x: Position.\n        // c: Array of control points.\n        let d = new Array(this.order + 1)\n        for (let j = 0; j <= this.order; j++) {\n            d[j] = controls[j + k - this.order]\n        }\n\n        for (let r = 1; r <= this.order; r++) {\n            for (let j = this.order; j >= r; j--) {\n                const alpha = (x - this.knots[j + k - this.order]) / (this.knots[j + 1 + k - r] - this.knots[j + k - this.order])\n                d[j] = (1.0 - alpha) * d[j - 1] + alpha * d[j]\n            }\n        }\n\n        return d[this.order]\n    }\n\n    numBasis() {\n        return this.knots.length - this.order - 1\n    }\n\n    drawBases(ctx: CanvasRenderingContext2D) {\n        let started = false;\n        let controls = new Array(this.numBasis()).fill(0);\n        const height = ctx.canvas.height\n        const width = ctx.canvas.width\n        const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n        ctx.clearRect(0, 0, width, height)\n        for (let control = 0; control < controls.length; control++) {\n            ctx.strokeStyle = colors[control];\n            ctx.beginPath()\n            controls[control] = 1;\n            for (let x = 0; x <= 1; x += (1 / 400)) {\n                let y = this.eval(x, controls);\n                y = height - (y * height);\n                if (!started) {\n                    ctx.moveTo(x * width, y);\n                    started = true;\n                }\n                ctx.lineTo(x * width, y);\n            }\n            controls[control] = 0;\n            ctx.stroke()\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        let started = false;\n        const height = ctx.canvas.height\n        const width = ctx.canvas.width\n        ctx.clearRect(0, 0, width, height)\n        ctx.strokeStyle = '#1976d2';\n        ctx.lineWidth = 3\n        ctx.beginPath()\n        const transformX = (x: number) => x * width\n        const transformY = (y: number) => y * height\n\n        for (let x = 0; x <= 1; x += (1 / 400)) {\n            let y = this.eval(x, this.controls);\n            y = (y * height);\n            if (!started) {\n                ctx.moveTo(x * width, y);\n                started = true;\n            }\n            ctx.lineTo(x * width, y);\n        }\n        ctx.stroke()\n\n        ctx.strokeStyle = 'black';\n        ctx.fillStyle = 'black';\n        for (let point of this.points) {\n            ctx.beginPath()\n            ctx.arc(transformX(point.x), transformY(point.y), 5, 0, 2 * Math.PI)\n            ctx.fill();\n            ctx.stroke()\n        }\n    }\n\n    drawLoop(ctx: CanvasRenderingContext2D) {\n        this.drawing = true\n        const callback = () => {\n            if (!this.drawing) {\n                return\n            }\n            const step_size = this.fitIter()\n            this.draw(ctx)\n            if (step_size > 1e-6) {\n                window.requestAnimationFrame(callback)\n            }\n        }\n        window.requestAnimationFrame(callback)\n    }\n}\n\nexport { Splines, Point }","import React from 'react';\nimport { Splines, Point } from './spline';\n\nfunction drawSine(ctx: CanvasRenderingContext2D, amplitude: number) {\n    // http://steve.hollasch.net/cgindex/math/inccos.html\n    const height = ctx.canvas.height;\n    const width = ctx.canvas.width;\n    const nslices = width;\n    const theta_increment = (2 * Math.PI) / nslices;\n    let Tcos = 1;   // Start from theta = zero.\n    let Tsin = 0;\n\n    let beta = Math.sin(theta_increment);\n    let alpha = Math.sin(theta_increment / 2);\n    alpha = 2 * alpha * alpha;\n\n    ctx.clearRect(0, 0, width, height);\n    ctx.beginPath();\n    ctx.moveTo(0, height / 2);\n    let points = []\n    for (let i = 0; i < nslices; ++i) {\n\n        // Use Tcos and Tsin\n        const x = i;\n        const y = (height / 2) + (amplitude / 100 * height / 2) * Tsin;\n        points.push([x, y])\n        ctx.lineTo(x, y);\n\n        let Ncos = (alpha * Tcos) + (beta * Tsin);\n        let Nsin = (alpha * Tsin) - (beta * Tcos);\n        Tcos -= Ncos;\n        Tsin -= Nsin;\n\n    }\n    ctx.stroke();\n    return points;\n}\n\ntype CanvasState = {\n    numberOfKnots: number\n    degreeOfSpline: number\n}\n\nclass Canvas extends React.Component<CanvasState> {\n    canvas: React.RefObject<HTMLCanvasElement>\n    ctx: CanvasRenderingContext2D | null = null\n    points: Point[] = []\n    splines: Splines\n\n    constructor(props: CanvasState) {\n        super(props);\n        this.canvas = React.createRef();\n        this.splines = new Splines(props.numberOfKnots, props.degreeOfSpline);\n    }\n\n    componentDidMount() {\n        this.componentDidUpdate()\n        if (this.ctx) {\n            let hue = 0;\n            let drawClickMeText = () => {\n                if (!this.ctx || this.splines.points.length) {\n                    return\n                }\n                this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height)\n                this.ctx.font = 'bold 36px sans-serif';\n                this.ctx.textAlign = 'center'\n                this.ctx.fillStyle = `hsla(${hue}, 100%, 50%, 1)`\n                hue += 0.5\n                this.ctx.fillText(\"Click Me\", this.ctx.canvas.width / 2, this.ctx.canvas.height / 2)\n                window.requestAnimationFrame(drawClickMeText)\n            }\n            window.requestAnimationFrame(drawClickMeText)\n        }\n    }\n\n    componentDidUpdate() {\n        this.ctx = this.ctx || this.canvas?.current?.getContext(\"2d\") as CanvasRenderingContext2D;\n        if (this.ctx === null) {\n            return null;\n        }\n        this.ctx.canvas.onclick = ev => {\n            const canvas = this.ctx?.canvas\n            if (!canvas) {\n                return;\n            }\n            const [height, width] = [canvas.height, canvas.width]\n            this.points.push(new Point(ev.offsetX / width, ev.offsetY / height))\n            this.splines.setPoints(this.points)\n            if (this.ctx) {\n                this.splines.drawLoop(this.ctx);\n            }\n        }\n    }\n\n    render() {\n        this.splines.setKnotsAndOrder(this.props.numberOfKnots, this.props.degreeOfSpline)\n        if (this.ctx) {\n            this.splines.drawLoop(this.ctx)\n        }\n        return (\n            <canvas ref={this.canvas} width={850} height={625} />\n        )\n    }\n}\nexport default Canvas","import React from 'react';\nimport Canvas from './canvas';\nimport { Slider } from '@mui/material';\nimport './App.css';\n\n\nfunction App() {\n  const [numberOfKnots, setNumberOfKnots] = React.useState(5);\n  const [degreeOfSpline, setDegreeOfSpline] = React.useState(3);\n  return (\n    <div className=\"App\">\n      <h1>Basis Splines Demo</h1>\n      <div id=\"instructions\">\n        <p><a href=\"https://en.wikipedia.org/wiki/B-spline\">Basis splines</a> are a powerful tool for expressing nonlinear statistical relationships.</p>\n        <p><b>Click🖱️</b> to add data points and fit a basis spline using gradient descent.</p>\n        <p><b>Use the sliders🎚️</b> to adjust the number of knots (polynomial pieces) and the degree (power) of the polynomials.</p>\n      </div>\n      <Canvas numberOfKnots={numberOfKnots} degreeOfSpline={degreeOfSpline}></Canvas>\n      <div>Number of Knots: <b>{numberOfKnots}</b></div>\n      <Slider\n        onChange={(e: any) => setNumberOfKnots(e.target.value)}\n        defaultValue={5}\n        min={2}\n        max={15}\n      />\n      <div>Degree of Spline: <b>{degreeOfSpline}</b></div>\n      <Slider\n        onChange={(e: any) => setDegreeOfSpline(e.target.value)}\n        defaultValue={3}\n        min={1}\n        max={5}\n      />\n    </div >\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}